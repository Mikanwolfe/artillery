program Artillery;
uses {imagination} Swingame, sgTypes, SysUtils, TerminalUserInput {and anime girls};
{
Comments from the Creator
None, for now.

Physical Quantities
Meters/Distance		-	Pixel(px)	= 1 Whole Number
Seconds/Time		-	Loop(l)		= Game loop, should be relatively stable.

To Do:
Explosion Animation - Eridani explosion?

Drawing the girls and fading them
UpdateExistences check for any tnaks left (might need new function)
Redoing shell "selection" sprite

Functional decomposition


		Damage	Expl	Drag		(VH  / H  / M  / L  / VL)
HE		H		M		H	  Drag: 0.95/0.96/0.97/0.98/0.99
HEAT	VH		L		M	  
HESH	M		VH		M	
AP		H		L		VL	
APHE	VH		L		L
APCR	VH		M		H		
ATGM	M		M		-VE	
}
Const
	SCREEN_HEIGHT=500;
	SCREEN_WIDTH=SCREEN_HEIGHT * 16 div 9;
	TARGET_FPS=60;
	GRAVITY_ACC=0.3;
	VEHICLE_MAXSPEED=0.95;				//maximum speed units/loop
	VEHICLE_ACC=0.15;					//0.5 px/(l^2)
	VEHICLE_BRAKE=0.4;					//Acts as friction, 0~1 . Brakes always kept on to limit top speed of vehicles.
	VEHICLE_FRICTION=0.8;				//When brake is off
	VEHICLE_SLOPE_RADIUS=5;				//Radius to scan to determine the slope
	VEHICLE_SIZE=5;						//Size in pixels to scan and determine vehicle position
	VEHICLE_SLOPE_MULTIPLIER=0.5;		//Determines how strongly slopes affect acceleration
	VEHICLE_SCALE_FACTOR=0.02;			//Scale bitmap
	DEGREE_INCREMENT=0.5;				//Increment per loop, in degrees
	POWER_INCREMENT=5;
	POWER_TO_PXL=0.022;
	ARTY_DATA_FILE='data.ia';
	PROJECTILE_RADIUS=2;
	VELOCITY_LOSS_MULTIPLIER=0.7;		//How much to reduce loss by and increase distance
	MAX_PROJECTILES=15;
	MAX_TRACERS=10;
	TRACER_FADE_TIME=MAX_TRACERS;		//Number of loops before tracer disappears
	DAMAGE_FADE_TIME=100;
	DAMAGE_TEXT_SPEED=1;
	EXPLOSION_FADE_TIME=30;
	TEXT_FADE_IN_TIME=150;
	TEXT_FADE_OUT_TIME=50;
	GIRL_FADE_TIME=50;
	GIRL_POSITION_OFFSET=10;
	GIRL_HEIGHT_OFFSET=-20;
	GIRL_MOVE_SPEED=3;
	POWER_BAR_HEIGHT=29;
	POWER_BAR_WIDTH=375;
	TRAVERSE_BAR_HEIGHT=11;
	TRAVERSE_BAR_WIDTH=375;
	
Type
	HeightMap = Array of Single;
	SPGType = (GWTiger, CGC, OBJ);
	//ShellType = (HE, HEAT, HESH, AP, APHE, APCR, ATGM); //High Explosive (High dmg, low pen), High-Explosive Anti-Tank (high pen, no dmg, no pen loss over distance), High-Explosive Squash-Head (averagepen, average damage), Armour Piercing (high pen, high damage, no expl.), Armour-Piercing High-Explosive (high pen, super-high damage, large pen loss over distance), Armour-Piercing Composite-Rigid (super-high pen, large pen loss over distance), Anti-Tank Guided Missile (sue me.).
	ShellType = (HE, HEAT, HESH, APHE);
	Team = (Red, Green, Blue, White, Black); //for MP
	TerrainType = (Hills, Plains, Mountains, Wasteland, Barren, Twilight);
	TerrainReduction = (Linear, Exponential);
	Direction = (Left, Right);
	
	
	//-------------------- Loaded with InitialiseData
	ShellData = Record
		Shell:ShellType;			//Load procedure takes care of this
		Name:String;
		MaxPenetration:Integer;		//in mm
		VelocityBleed:Single;		//between 0 and 1, nominally 0.9-0.99, HE loses more (0.9), HESH even more, APHE/AP not as much (0.95+), ATGMs >1
		Damage:Integer;
		PenetrationLoss:Boolean;	//Whether or not to lose peneration over distance. Only for HE/HESH/HEAT/ATGMs
		BlastRadius:Integer;			//Pixels, left and right. HE~30, AP~5, etc.
		IsGuided:Boolean;			//Determines whether or not we guide it
		TransferCoefficient:Single; //used for ATGMs, set to 0 for everything else, normally low, 0.1-0.4
	end;
	SPGSprite = Record //SPG Sprite Data
		HullFile:AnsiString;
		BarrelFile:AnsiString;
		GirlFile:AnsiString;
		HullBitmap:Bitmap;
		BarrelBitmap:Bitmap;
		GirlBitmap:Bitmap;
	end;
	SPGData = Record //The SPG 's data
		Model:SPGType;							//Load procedure takes care of this
		Name:String;
		MaxHP:Integer;
		TopArmour, FrontArmour, RearArmour:Integer;
		MaxGunVelocity:Single;					//in px/l
		GunElevation, GunDepression:Integer;	//in degrees
		ShellStat: Array of ShellData;
		Sprite:SPGSprite;
		TraverseLimit:Integer;					//in px
		MaxNumberShells:Integer;
	end;
	Map = Record
		Terrain: TerrainType;					//Load procedure takes care of this
		Name:String;
		Description:String;
		SkyColour:Color;
		C1,C2,C3:Color;
		MaxRoughness, MinRoughness:Single;
	end;
	{
	ShellColourData = Record
		Shell: ShellType;
		Colour:Color;
	end;
	}
	//--------------------------------------------------
	
	Ammunition = Record			//This tells the game how many of each the player has left
		Shell:ShellType;		//The actual shell dynamics are taken from 
		Number:Integer;			//IAData.SPG[Integer(enum)].ShellStat[Integer(Enum)]
	end;
	
	TracerData = Record
		Exists:Boolean;
		Colour:Color;
		FadeTime:Integer;		//Number of loops before WE DESTROY THE TRACER
		x,y:Single;
	end;
	
	ProjectileData = Record
		Exists:Boolean;
		Owner:Integer;			//Player that fired the projectile
		Shell:ShellType;		//To determine damage
		Colour:Color;			//"Color" = Type, "Colour" = everything else
		x,y:Single;				//Originally used swingame, was useless.
		dx,dy:Single;			//velocity
		Tracer: Array[0..MAX_TRACERS-1] of TracerData;
	end;
	
	DamageTextData = Record
		Exists:Boolean;
		Value:String;
		x,y,dy:Single;
		FadeTime:Integer;
	end;
	
	GirlData = Record
		Exists:Boolean;
		Side:Direction;
		Looks:Bitmap;
		x,y,dx:Single;
		FadeTime:Integer;
	end;
	
	ExplosionData = Record
		Exists:Boolean;
		Radius:Integer;
		x,y:Single;
		FadeTime:Integer;
	end;
	
	PlayerData = Record
		Name: String;
		SPG:SPGType;
		Sprite:SPGSprite;
		HP:Integer;
		Exists:Boolean;
		AmmunitionRack: Array[0..Integer(High(ShellType))] of Ammunition;
		TraverseLeft:Single;
		Credits:Integer;
		CurrentTeam:Team;
		Acc,Vel,Pos:Single;				//Acceleration, Velocity, X-Position
		Facing:Direction;				//Current vehicle facing
		GunAngle:Single;				//Current gun Angle; In radians
		VehicleAngle:Single;			//Angle of player's Vehicle on Terrain
		BrakesOn:Boolean;				//Whether or not brakes are on. Normally on.
		ProjectilePower:Single;			//for shooting
		PreviousProjectilePower:Single;			//for shooting
		FireProjectile:Boolean;
		ActiveShellIndex:Integer;
	end;
	
	ProgressBarData = Record
		Full,Empty:Bitmap;
	end;
	
	MainGameData = Record
		Player: Array of PlayerData;
		SPG: Array of SPGData;
		Projectile: Array[0..MAX_PROJECTILES-1] of ProjectileData;
		DamageText: Array[0..MAX_PROJECTILES-1] of DamageTextData;
		Explosion: Array[0..MAX_PROJECTILES-1] of ExplosionData;
		ShellColour: Array[0..Integer(High(ShellType))] of Color; //Array index is the same as shell type.
		Girl: Array[0..MAX_PROJECTILES-1] of GirlData;
		ShellPanel,ShellDesc:Panel;
		GroundMap: HeightMap;
		CurrentPlayer:Integer;
		ShowingShellDesc:Boolean;
		//ActiveShellIndex:Integer;
		PowerBar:ProgressBarData;
		TraverseBar:ProgressBarData;
		MenuExitRequested:Boolean;
		ExitRequested:Boolean;
		NewGameRequested:Boolean;
	end;

procedure DrawMap(Colour:Color;groundMap:HeightMap);
var
	i:Integer;
begin
	for i:=0 to SCREEN_WIDTH do
	begin
		DrawLine(Colour,i,SCREEN_HEIGHT-groundMap[i],i,SCREEN_HEIGHT);
	end;
end;

function Power(base,expo:Double):Integer;
begin
	result:=Round(Exp(expo*Ln(base))); 
end;

function FPower(base,expo:Double):double; //floating point power
begin
	result:=Exp(expo*Ln(base)); 
end;

function Ceil(x:Double):Integer;
begin
	result:=trunc(x)+1;
end;

function PowerCeil(base:Double;expo:Double):Integer;
//returns the overdetermined exponent to the base such that expo^result>=base
begin
	result:=ceil(ln(base)/ln(expo))
end;

function FRandBtw(min:Double; max: Double):Double;
begin
	result:= min + (max - min) * rnd();
end;

function RandDisplacement(displacement:Integer):Integer;
//returns a value between [-displacement, displacement]
begin
	result:=round(rnd()*displacement * 2 - displacement);
end;

procedure ClearTerrain(var groundMap:HeightMap);
var
	i:Integer;
begin
	for i:=Low(groundMap) to High(groundMap) do
	begin
		groundMap[i]:=0;
	end;
end;

function Rad(degr:Single):Single;
begin
	result:=degr * 2 * pi / 360;
end;

function deg(Radi:Single):Single;
begin
	result:=Radi * 360 / ( 2 * pi);
end;


function buttonClicked(buttonX, buttonY: Single; buttonWidth, buttonHeight: Integer): Boolean;
var
	x, y: Single;
	buttonRightLimit, buttonBottomLimit: Single;

begin
	x := MouseX();
	y := MouseY();
	buttonRightLimit := buttonX + buttonWidth;
	buttonBottomLimit := buttonY + buttonHeight;
	result := false;
	
	if MouseClicked(LeftButton) then
	begin
		if (buttonX<=x) and (x<=buttonRightLimit) and (buttonY<=y) and (y<=buttonBottomLimit) then
		begin
			result := true;
		end;
	end;
end;

procedure DrawTextCentre(Colour:Color;message:String;x,y:Single);
var
	textPos:Single;
	menuText:String;
begin
	textPos:=x-Length(message)*3.5; 
	DrawText(Message,Colour,textPos,y-50);
end;

procedure GenerateTerrain(var groundMap:HeightMap; displacement:Integer; roughness:Double; reductionType:TerrainReduction);
var
	i,j,currentIndex,segments,segmentLength,terrainWidth,exponent:Integer;
	reduction:Double;
begin
	reduction:= 1 / fPower(2,roughness);
	
	exponent:=powerCeil(SCREEN_WIDTH,2);
	terrainWidth:=power(2,exponent); //SCREEN_WIDTH of 800 gives log_2 800 ~ 9.64... ~ 10. 2^10=1024
	setLength(groundMap, terrainWidth+1);
	
	groundMap[0]:=SCREEN_HEIGHT/3 + randDisplacement(displacement);
	groundMap[terrainWidth]:=SCREEN_HEIGHT/2 + randDisplacement(displacement);
	
	for i:=0 to exponent do
	begin
		segments:=power(2,i);
		segmentLength:=round((terrainWidth / segments) / 2);
		
		for j:=1 to segments do 
		begin
			currentIndex:= (j * segmentLength * 2) - segmentLength; //segmentLength * 2 = distance between segment midpoints
			groundMap[currentIndex]:=(groundMap[currentIndex-segmentLength] + groundMap[currentIndex+segmentLength]) / 2;
			groundMap[currentIndex]:=groundMap[currentIndex] + randDisplacement(displacement);
		end;
		case reductionType of
			Linear: displacement:=round(displacement * reduction);
			Exponential: displacement:=trunc(power(displacement,reduction));
		end;
	end;
end;

function GroundPosition(x:Integer;IAData:MainGameData):Integer;
begin
	result:=Round(SCREEN_HEIGHT-IAData.GroundMap[x]);
end;

function ReadBooleanLine(var dataFile:TextFile):Boolean;
var
	readString:String;
begin
	ReadLn(dataFile,readString);
	if (readString = '1') then
		begin
			result:=true;
		end
		else
		begin
			result:=false;
		end;
end;

procedure InitialiseData(var IAData:MainGameData; dataLocation:String);
var
	dataFile: TextFile;
	arty,i:Integer;
begin
	//WriteLn('Loading from ',dataLocation);
	AssignFile(dataFile,dataLocation);
	reset(dataFile);
	//WriteLn('Data File file opened');
	ReadLn(dataFile); //First line is not important
	//readln (file, towhere)
	
	SetLength(IAData.SPG,Integer(High(SPGType))+1);
	for arty:=0 to Integer(High(SPGType)) do
	begin
		IAData.SPG[arty].Model:=SPGType(arty);
		ReadLn(dataFile,IAData.SPG[arty].Name);
		ReadLn(dataFile,IAData.SPG[arty].MaxHP);
		ReadLn(dataFile,IAData.SPG[arty].TopArmour);
		ReadLn(dataFile,IAData.SPG[arty].FrontArmour);
		ReadLn(dataFile,IAData.SPG[arty].RearArmour);
		ReadLn(dataFile,IAData.SPG[arty].MaxGunVelocity);
		ReadLn(dataFile,IAData.SPG[arty].GunElevation);
		ReadLn(dataFile,IAData.SPG[arty].GunDepression);
		//WriteLn('passed main, entering into loop for shells for ARTY: ',arty);
		SetLength(IAData.SPG[arty].ShellStat,Integer(High(ShellType))+1);
		for i:=0 to Integer(High(ShellType)) do
		begin
			ReadLn(dataFile);
			IAData.SPG[arty].ShellStat[i].Shell:=ShellType(i);
			ReadLn(dataFile,IAData.SPG[arty].ShellStat[i].Name);
			ReadLn(dataFile,IAData.SPG[arty].ShellStat[i].MaxPenetration);
			ReadLn(dataFile,IAData.SPG[arty].ShellStat[i].VelocityBleed);
			ReadLn(dataFile,IAData.SPG[arty].ShellStat[i].Damage);
			IAData.SPG[arty].ShellStat[i].PenetrationLoss:=ReadBooleanLine(dataFile);
			ReadLn(dataFile,IAData.SPG[arty].ShellStat[i].BlastRadius);
			IAData.SPG[arty].ShellStat[i].IsGuided:=ReadBooleanLine(dataFile);
			IAData.SPG[arty].ShellStat[i].TransferCoefficient:=0;
			if (IAData.SPG[arty].ShellStat[i].IsGuided) then ReadLn(dataFile,IAData.SPG[arty].ShellStat[i].TransferCoefficient);
			//WriteLn('passed shell loop for ShellType: ',i);
		end;
		//WriteLn('passed shell loops.');
		ReadLn(dataFile);
		ReadLn(dataFile,IAData.SPG[arty].Sprite.HullFile);
		ReadLn(dataFile,IAData.SPG[arty].Sprite.BarrelFile);
		ReadLn(dataFile,IAData.SPG[arty].Sprite.GirlFile);
		ReadLn(dataFile,IAData.SPG[arty].TraverseLimit);
		ReadLn(dataFile,IAData.SPG[arty].MaxNumberShells);
		ReadLn(dataFile);
		//WriteLn('end of loop.');
	end;
end;

procedure LoadResources(var IAData:MainGameData);
var
	i:Integer;
begin
	for i:=0 to Integer(High(SPGType)) do
	begin
	//LoadTransparentBitmapNamed(IAData.SPG[i].Sprite.HullFile,IAData.SPG[i].Sprite.HullFile,RGBAColor(0,0,0,0));
	//LoadTransparentBitmapNamed(IAData.SPG[i].Sprite.BarrelFile,IAData.SPG[i].Sprite.BarrelFile,RGBAColor(0,0,0,0));
	//LoadTransparentBitmapNamed(IAData.SPG[i].Sprite.GirlFile,IAData.SPG[i].Sprite.GirlFile,RGBAColor(0,0,0,0));
	LoadBitmapNamed('shellsdesc.PNG','shellsdesc.PNG');
	
	LoadBitmapNamed(IAData.SPG[i].Sprite.HullFile,IAData.SPG[i].Sprite.HullFile);
	LoadBitmapNamed(IAData.SPG[i].Sprite.BarrelFile,IAData.SPG[i].Sprite.BarrelFile);
	LoadBitmapNamed(IAData.SPG[i].Sprite.GirlFile,IAData.SPG[i].Sprite.GirlFile);
	
	IAData.SPG[i].Sprite.HullBitmap:=BitmapNamed(IAData.SPG[i].Sprite.HullFile);
	IAData.SPG[i].Sprite.BarrelBitmap:=BitmapNamed(IAData.SPG[i].Sprite.BarrelFile);
	IAData.SPG[i].Sprite.GirlBitmap:=BitmapNamed(IAData.SPG[i].Sprite.GirlFile);
	
	IAData.PowerBar.Empty:=LoadBitmapNamed('EmptyPowerBar' ,'power_back.png' );
    IAData.PowerBar.Full := LoadBitmapNamed('FullPowerBar' ,'power_bar.png' );
	
	IAData.TraverseBar.Empty:=LoadBitmapNamed('EmptyTraverseBar' ,'moving_back.png' );
	IAData.TraverseBar.Full := LoadBitmapNamed('FullTraverseBar' ,'moving_bar.png' );
	
	IAData.SPG[i].Sprite.HullBitmap:=RotateScaleBitmap(IAData.SPG[i].Sprite.HullBitmap,0,VEHICLE_SCALE_FACTOR);
	end;
	
	//Load shell colours
	IAData.ShellColour[0]:=RGBAColor(245,110,10,255);		{HE}
	IAData.ShellColour[1]:=RGBAColor(150,150,100,255);		{HEAT}
	IAData.ShellColour[2]:=RGBAColor(145,250,180,255);		{HESH}
	IAData.ShellColour[3]:=RGBAColor(125,3,3,255);			{AP}
	//IAData.ShellColour[4]:=RGBAColor(3,35,195,255);			{APHE}
	//IAData.ShellColour[5]:=RGBAColor(0,15,55,255);			{APCR}
	//IAData.ShellColour[6]:=RGBAColor(225,10,230,255);		{ATGM}
	
end;

procedure SetShellTypes(IAData:MainGameData);          
var                                                    
	i:Integer;                                         
begin                                                  
	i:=IAData.CurrentPlayer;                           

	CheckBoxSetState('ShellButton1', false);           
	CheckBoxSetState('ShellButton2', false);           
	CheckBoxSetState('ShellButton3', false);           
	CheckBoxSetState('ShellButton4', false);           
	CheckBoxSetState('InfoButton', IAData.ShowingShellDesc);           
	//CheckBoxSetState('ShellButton5', false);
	//CheckBoxSetState('ShellButton6', false);
	//CheckBoxSetState('ShellButton7', false);
	
	case IAData.Player[i].ActiveShellIndex of
		0: CheckBoxSetState('ShellButton1', true);
		1: CheckBoxSetState('ShellButton2', true);
		2: CheckBoxSetState('ShellButton3', true);
		3: CheckBoxSetState('ShellButton4', true);
		//4: CheckBoxSetState('ShellButton5', true);
		//5: CheckBoxSetState('ShellButton6', true);
		//6: CheckBoxSetState('ShellButton7', true);
	end;
	
end;

function RandomPlayer(IAData:MainGameData):Integer;
begin
	if (Length(IAData.Player)=1) then
	begin
		result:=0;
	end
	else
	begin
		result:=Rnd(High(IAData.Player));
	end;
end;

function HandleNumberInput():Integer;
var
	i:Integer;
begin
	result:=-1;
	for i:=48 to 57 do //0 to 9 Keycode
	begin
		if KeyDown(KeyCode(i)) then result:=i - 48;
	end;
end;

{ procedure SelectNumberPlayers(var IAData:MainGameData); //Will show a panel indicating number of players
var
	numberPlayers,newNumberPlayers:Integer;
	exitRequested:Boolean;
	strNumberPlayers:String;
begin
	exitRequested:=false;
	numberPlayers:=1;
	
	repeat
		ProcessEvents();
		ClearScreen(ColorWhite);
		newNumberPlayers:=HandleNumberInput();
		if not (newNumberPlayers=-1) then numberPlayers:=newNumberPlayers;
		if (numberPlayers=0) then numberPlayers:=1;
		Str(numberPlayers,strNumberPlayers);
		DrawTextCentre(ColorBlack,'Number of Players:',SCREEN_WIDTH/2,170);
		DrawTextCentre(ColorBlack,strNumberPlayers,SCREEN_WIDTH/2,185);		
		DrawTextCentre(ColorBlack,'OK',SCREEN_WIDTH/2,200);
		exitRequested:=buttonClicked(SCREEN_WIDTH/2 - 10,140,25,15);
		if KeyDown(VK_KP_ENTER) then exitRequested:=true;
		//FillRectangle(ColorBlack,SCREEN_WIDTH/2 - 10,140,25,15);
		if WindowCloseRequested() then begin exitRequested:=true; IAData.ExitRequested:=true; end;
		RefreshScreen(TARGET_FPS);
	until exitRequested;
	SetLength(IAData.Player,numberPlayers);
end; }

procedure SelectNumberPlayers(var IAData:MainGameData); //Will show a panel indicating number of players
var
	numberPlayers,newNumberPlayers:Integer;
	exitRequested:Boolean;
	strNumberPlayers:String;
	guiFont:Font;
begin
	exitRequested:=false;
	numberPlayers:=1;
	guiFont:=LoadFontNamed('guiFont','maven_pro_regular.ttf',12);
	StartReadingText(ColorBlack,20,guiFont,Round(SCREEN_WIDTH/2),150);
	repeat
		ProcessEvents();
		ClearScreen(ColorWhite);
		
		DrawTextCentre(ColorBlack,'Number of Players:',SCREEN_WIDTH/2,170);
		if not ReadingText() then begin numberPlayers:=StrToInt(EndReadingText()); exitRequested:=true; end;
		if WindowCloseRequested() then begin exitRequested:=true; IAData.ExitRequested:=true; end;
		RefreshScreen(TARGET_FPS);
	until exitRequested;
	SetLength(IAData.Player,numberPlayers);
end;

procedure SelectVehicle(var player:PlayerData); //Select your girl now!
var
	selection:Integer;
	SelectedVehicle:SPGType;
begin
	//WriteLn('Debug: Enter in enum index, pref. 0');
	selection:=ReadInteger('Vehicle: ');
	SelectedVehicle:=SPGType(selection);
	player.SPG:=SelectedVehicle;
end;

procedure ReadUserNames(var IAData:MainGameData);
var
	i:Integer;
	currentName,prompt,strPlayer:String;
	exitRequested:Boolean;
	guiFont:Font;
begin
	guiFont:=LoadFontNamed('guiFont','maven_pro_regular.ttf',12);
	for i:=0 to High(IAData.Player) do
	begin
		exitRequested:=false;
		StartReadingText(ColorBlack,20,guiFont,Round(SCREEN_WIDTH/2),150);
		repeat
			ProcessEvents();
			ClearScreen(ColorWhite);
			str(i+1,strPlayer);
			prompt:=Concat('Player ',strPlayer,'''s name');
			DrawTextCentre(ColorBlack,prompt,SCREEN_WIDTH/2,170);
			if not ReadingText() then begin IAData.Player[i].Name:=EndReadingText(); exitRequested:=true; end;
			RefreshScreen(TARGET_FPS);
		until exitRequested;
		//IAData.Player[i].Name:=ReadString('Name: ');
	end;
end;

procedure SelectPlayerVehicles(var IAData:MainGameData);
var
	i,j,k,offset:Integer;
	prompt:String;
	exitRequested:Boolean;
	Colour:Color;
begin
	Colour:=RGBAFloatColor(0.4,0.4,0.4,1);
	offset:=30;
	
	for i:=Low(IAData.Player) to High(IAData.Player) do
	begin
		IAData.Player[i].SPG:=SPGType(-1);
	end;
	for j:=Low(IAData.Player) to High(IAData.Player) do
	begin
		exitRequested:=false;
		//SelectVehicle(IAData.Player[i]);
		
		repeat
			ProcessEvents();
			ClearScreen(ColorWhite);
			prompt:=Concat(IAData.Player[j].Name,', pick your vehicle:');
			DrawTextCentre(ColorBlack,prompt,SCREEN_WIDTH/2,130);
			
			FillRectangle(RGBAFloatColor(0.94,0.94,0.94,0.7),0,110 + offset,SCREEN_WIDTH,160);
			DrawTextCentre(ColorBlack,'G.W. Tiger',Round(SCREEN_WIDTH/2),175 + offset);
			DrawTextCentre(Colour,'Long Gun Range, Low Damage, Powerful HEAT Shells',Round(SCREEN_WIDTH/2),190 + offset);
			DrawTextCentre(ColorBlack,'CGC',Round(SCREEN_WIDTH/2),225 + offset);
			DrawTextCentre(Colour,'High Damage, High Blast Radius, Low Range, Best HESH Shells',Round(SCREEN_WIDTH/2),240 + offset);
			DrawTextCentre(ColorBlack,'Oject',Round(SCREEN_WIDTH/2),275 + offset);
			DrawTextCentre(Colour,'Very good Damage, Good Range, Low HP, Strong APHE Shells',Round(SCREEN_WIDTH/2),290 + offset);
			
			for k:=Low(IAData.Player) to j-1 do
			begin
				if (IAData.Player[k].SPG<>SPGType(-1)) then begin
					prompt:=Concat(IAData.Player[k].Name,' : ',IAData.SPG[Ord(IAData.Player[k].SPG)].Name);
				end else begin
					prompt:=Concat(IAData.Player[k].Name,': ');
				end;
				DrawTextCentre(ColorBlack,prompt,SCREEN_WIDTH/2,360+(k+1)*20);
			end;
			
			if buttonClicked(210,140,512,52) then begin IAData.Player[j].SPG:=SPGType(0); exitRequested:=true; end;
			if buttonClicked(210,190,512,52) then begin IAData.Player[j].SPG:=SPGType(1); exitRequested:=true; end;
			if buttonClicked(210,240,512,52) then begin IAData.Player[j].SPG:=SPGType(2); exitRequested:=true; end;
			
			if WindowCloseRequested() then begin exitRequested:=true; IAData.ExitRequested:=true; end;
			RefreshScreen(TARGET_FPS);
		until exitRequested;
		
	end;
end;

procedure NewGame(var IAData:MainGameData);
var
	i:Integer;

begin
	SelectNumberPlayers(IAData);
	ReadUserNames(IAData);
	SelectPlayerVehicles(IAData);
end;

procedure DrawMenu(IAData:MainGameData;MenuAlpha:Integer);
var
	middleOfScreen,i:Integer;
	alpha:Single;
	menuColour,mapColour:Color;
begin
	ClearScreen(ColorWhite);
	middleOfScreen:=Round(SCREEN_WIDTH/2);
	alpha:=MenuAlpha / TEXT_FADE_IN_TIME;
	
	menuColour:=RGBAFloatColor(0,0,0,alpha);
	DrawTextCentre(menuColour,'Artillery',middleOfScreen,100);
	DrawTextCentre(menuColour,'New Game',middleOfScreen,150);
	DrawTextCentre(menuColour,'Exit',middleOfScreen,180);
	
	DrawMap(ColorGreen,IAData.GroundMap);
	RefreshScreen();
	
	if IAData.NewGameRequested then
	begin
		for i:=TEXT_FADE_OUT_TIME downto 0 do
		begin
			ClearScreen(ColorWhite);
			alpha:=i / TEXT_FADE_OUT_TIME;
			menuColour:=RGBAFloatColor(0,0,0,alpha);
			mapColour:=RGBAFloatColor(BlueOf(colorGreen) / 8,GreenOf(colorGreen) / 8,RedOf(colorGreen) / 8,alpha);
			DrawTextCentre(menuColour,'Artillery',middleOfScreen,100);
			DrawTextCentre(menuColour,'New Game',middleOfScreen,150);
			DrawTextCentre(menuColour,'Exit',middleOfScreen,180);
			DrawMap(mapColour,IAData.GroundMap);
			RefreshScreen();
		end;
	end;

end;

procedure HandleMenuInput(var IAData:MainGameData);
var
	buttonNewGame,buttonExit:Boolean;
begin
	buttonNewGame:=buttonClicked(411,96,75,18);
	
	buttonExit:=buttonClicked(423,126,50,18);
	if buttonNewGame then begin IAData.NewGameRequested:=true; IAData.MenuExitRequested:=true; end;
	if buttonExit then begin IAData.ExitRequested:=true; IAData.MenuExitRequested:=true; end;
end;

procedure UpdateMenu(var IAData:MainGameData;var MenuAlpha:Integer);
begin
	if (MenuAlpha < TEXT_FADE_IN_TIME) then
		MenuAlpha+=1;
end;

procedure Menu(var IAData:MainGameData);
var
	choice:String;
	MenuAlpha:Integer;
begin
	//Show a menu here, but for debug purposes, we'll say it's a New Game!
	//map adjustment can be made in "Custom game" option
	
	IAData.ExitRequested:=false;
	IAData.MenuExitRequested:=false;
	IAData.NewGameRequested:=false;
	GenerateTerrain(IAData.GroundMap,round(SCREEN_HEIGHT / 5),fRandBtw(0.7, 1.6), Linear);
	MenuAlpha:=0;
	repeat
		//NewGame(IAData);
		//exitRequested:=true;
		HandleMenuInput(IAData);
		UpdateMenu(IAData,MenuAlpha);
		DrawMenu(IAData,MenuAlpha);
		ProcessEvents();
		if IAData.NewGameRequested then NewGame(IAData);
		if WindowCloseRequested() then IAData.MenuExitRequested:=True;
	until IAData.MenuExitRequested;
end;

procedure DrawMarker(Colour:Color;x:Integer;y:Single;radian:Single;startPoint,Length:Integer;facing:Direction);
var
	endPoint:Integer;
begin
	endPoint:=Length+startPoint;
	case facing of
		Left: DrawLine(Colour,x-startPoint*cos(radian),y-startPoint*sin(radian),x-endPoint*cos(radian),y-endPoint*sin(radian));
		Right: DrawLine(Colour,x+startPoint*cos(radian),y-startPoint*sin(radian),x+endPoint*cos(radian),y-endPoint*sin(radian));
	end;
	
end;

procedure DrawPlayers(IAData:MainGameData);
var
	i:Integer;
	rad,y,x,textPos:Single;
	//vehicleBMP,gunBMP:Bitmap;
	name:String;
begin
	for i:=Low(IAData.Player)  to High(IAData.Player) do
	begin
		if (IAData.Player[i].Exists) then
		begin
			x:=IAData.Player[i].pos;
			//vehicleBMP:=IAData.Player[i].Sprite.HullBitmap;
			//vehicleBMP:=RotateScaleBitmap(vehicleBMP,deg(IAData.Player[i].VehicleAngle),1);
			y:=GroundPosition(Round(x),IAData);
			
			//DrawBitmap(vehicleBMP,x-20,y-15);
			FillCircle(ColorBlack,x,y,3);
			name:=IAData.Player[i].Name;
			textPos:=x-Length(name)*3.5; //Length one one SwinGame character is 7 pixels
			DrawText(Name,ColorBlack,textPos,y-50);
			case IAData.Player[i].Facing of
				Left: 
					begin
					FillCircle(ColorRed,x-4,y,3);
					end;
				Right: 
					begin
					FillCircle(ColorRed,x+4,y,3); 
					end;
			end;
		end;
	end;
end;

{ procedure DrawPowerBar(IAData:MainGameData;x,y:Integer);
var
	i,Width,previousLocation:Integer;
	maxPower:Single;
	partRect : Rectangle;
begin
	i:=IAData.CurrentPlayer;
	maxPower:=IAData.SPG[Ord(IAData.Player[i].SPG)].MaxGunVelocity;
	Width:=Round(POWER_BAR_WIDTH * IAData.Player[i].ProjectilePower / maxPower);
	previousLocation:=Round(POWER_BAR_WIDTH * IAData.Player[i].PreviousProjectilePower / maxPower);
	partRect := RectangleFrom(0 ,0 ,Width ,POWER_BAR_HEIGHT );
	
	DrawBitmap(IAData.PowerBar.Empty,x,y);
	DrawBitmapPart(IAData.PowerBar.Full ,partRect ,x ,y );
	DrawVerticalLine(ColorBlack,x+previousLocation,y,y+POWER_BAR_HEIGHT);
end; }

procedure DrawPowerBar(IAData:MainGameData;x,y:Integer);
var
	i,Width,previousLocation:Integer;
	maxPower:Single;
	partRect : Rectangle;
begin
	i:=IAData.CurrentPlayer;
	maxPower:=IAData.SPG[Ord(IAData.Player[i].SPG)].MaxGunVelocity;
	Width:=Round(POWER_BAR_WIDTH * IAData.Player[i].ProjectilePower / maxPower);
	previousLocation:=Round(POWER_BAR_WIDTH * IAData.Player[i].PreviousProjectilePower / maxPower);
	partRect := RectangleFrom(0 ,0 ,Width ,POWER_BAR_HEIGHT );
	
	FillRectangle(RGBAColor(247,202,47,255),x,y + 5,Width,20);
	FillRectangle(ColorBlack,x - 2,y,3,30);
	FillRectangle(ColorBlack,x + POWER_BAR_WIDTH - 3,y,3,30);
	//DrawBitmap(IAData.PowerBar.Empty,x,y);
	//DrawBitmapPart(IAData.PowerBar.Full ,partRect ,x ,y );
	DrawVerticalLine(ColorBlack,x+previousLocation,y,y+POWER_BAR_HEIGHT);
end;

{ procedure DrawTraverseBar(IAData:MainGameData;x,y:Integer);
var
	i,Width,previousLocation:Integer;
	Traverse:Single;
	partRect : Rectangle;
begin
	i:=IAData.CurrentPlayer;
	Traverse:=IAData.SPG[Ord(IAData.Player[i].SPG)].TraverseLimit;;
	Width:=Round(TRAVERSE_BAR_WIDTH * IAData.Player[i].TraverseLeft / Traverse);
	partRect := RectangleFrom(0 ,0 ,Width ,TRAVERSE_BAR_HEIGHT );
	
	DrawBitmap(IAData.TraverseBar.Empty,x,y);
	DrawBitmapPart(IAData.TraverseBar.Full ,partRect ,x ,y );
end; }

procedure DrawTraverseBar(IAData:MainGameData;x,y:Integer);
var
	i,Width,previousLocation:Integer;
	Traverse:Single;
	partRect : Rectangle;
begin
	i:=IAData.CurrentPlayer;
	Traverse:=IAData.SPG[Ord(IAData.Player[i].SPG)].TraverseLimit;;
	Width:=Round(TRAVERSE_BAR_WIDTH * IAData.Player[i].TraverseLeft / Traverse);
	partRect := RectangleFrom(0 ,0 ,Width ,TRAVERSE_BAR_HEIGHT );
	
	FillRectangle(RGBAColor(0,64,128,255),x,y + 4,Width,4);
	FillRectangle(ColorBlack,x - 2,y,3,12);
	FillRectangle(ColorBlack,x + POWER_BAR_WIDTH - 3,y,3,12);
end;

procedure DrawShellDesc(ShowingShellDesc:Boolean);
begin
	if ShowingShellDesc then DrawBitmap('shellsdesc.PNG',50,95);
end;

procedure DrawHUD(IAData:MainGameData);
var
	vehicleName:String;
	playerVehicle:SPGType;
	hudString,gunString,angleString,speedString,powerString,nameString:String;
	gunPosition:Single;
	i:Integer;
begin
	i:=IAData.CurrentPlayer;
	playerVehicle:=IAData.Player[i].SPG;
	vehicleName:=IAData.SPG[Ord(playerVehicle)].Name;
	Str(IAData.Player[i].GunAngle * 360 / (2 * pi):0:2,angleString);
	Str(Abs(IAData.Player[i].vel):0:2,speedString);
	Str(Abs(IAData.Player[i].ProjectilePower):0:2,powerString);
	nameString:=Concat('Current Player: ',IAData.Player[i].Name);
	hudString:=Concat('Vehicle: ',vehicleName);
	gunString:=Concat('Angle:   ',angleString,' Degrees');
	speedString:=Concat('Speed:   ',speedString,' px/l');
	powerString:=Concat('Power:   ',powerString,' px/l');
	DrawShellDesc(IAData.ShowingShellDesc);
	DrawPowerBar(IAData,445,438);
	DrawTraverseBar(IAData,445,472);
	
	DrawText(nameString,ColorBlack,50,35);
	DrawText(hudString,ColorBlack,50,50);
	DrawText(gunString,ColorBlack,50,60);
	DrawText(speedString,ColorBlack,50,70);
	DrawText(powerString,ColorBlack,50,80);
	DrawInterface();
end;

procedure DrawProjectiles(IAData:MainGameData);
var
	i,j,k:Integer;
begin
	i:=IAData.CurrentPlayer;
	
	for j:=0 to High(IAData.Projectile) do
	begin
		if (IAData.Projectile[j].Exists) then
		begin
			FillCircle(IAData.Projectile[j].Colour,IAData.Projectile[j].x,SCREEN_HEIGHT-IAData.Projectile[j].y,PROJECTILE_RADIUS);
			
			//draw tracers and simulate their fade
		end;
		for k:=0 to High(IAData.Projectile[j].Tracer) do
		begin
			//WriteLn('Tracer ',k,' current state: ',IAData.Projectile[j].Tracer[k].Exists, ', Fade timer:',IAData.Projectile[j].Tracer[k].FadeTime);
			if (IAData.Projectile[j].Tracer[k].Exists) then
			begin
				FillCircle(IAData.Projectile[j].Tracer[k].Colour,IAData.Projectile[j].Tracer[k].x,SCREEN_HEIGHT-IAData.Projectile[j].Tracer[k].y,PROJECTILE_RADIUS);
			end;
		end;
	end;
end;

procedure DrawAngleMarkers(IAData:MainGameData);
var
	i,x:Integer;
	y,radian,radDepression,radElevation,radVechicle:Single;
begin
	i:=IAData.CurrentPlayer;
	x:=Round(IAData.Player[i].pos);
	y:=GroundPosition(x,IAData);
	radVechicle:=IAData.Player[i].VehicleAngle;
	radian:=IAData.Player[i].GunAngle+radVechicle;
	radElevation:=Rad(IAData.SPG[Ord(IAData.Player[i].SPG)].GunElevation)+radVechicle;
	radDepression:=-Rad(IAData.SPG[Ord(IAData.Player[i].SPG)].GunDepression)+radVechicle;
	
	DrawMarker(ColorBlack,x,y,radian,10,20,IAData.Player[i].Facing);
	DrawMarker(ColorRed,x,y,radElevation,10,20,IAData.Player[i].Facing);
	DrawMarker(ColorRed,x,y,radDepression,10,20,IAData.Player[i].Facing);
end;

procedure DrawHealthBars(IAData:MainGameData);
var
	i,x,y,w,h,fill:Integer;
begin
	w:=40;
	h:=4;
	for i:=Low(IAData.Player) to High(IAData.Player) do
	begin
		if (IAData.Player[i].Exists) then
		begin
			fill:=Round( (w-2) * (IAData.Player[i].HP / IAData.SPG[Ord(IAData.Player[i].SPG)].MaxHP));
			x:=Round(IAData.Player[i].pos - w / 2);
			y:=GroundPosition(Round(IAData.Player[i].pos),IAData)+10;
			FillRectangle(ColorWhite,x,y,w,h);
			FillRectangle(ColorRed,x+1,y+1,w-2,Round(h/2));
			FillRectangle(ColorGreen,x+1,y+1,fill,Round(h/2));
		end;
	end;
end;

procedure DrawDamageText(IAData:MainGameData);
var
	i:Integer;
	Alpha,x,y:Single;
begin
	for i:=0 to High(IAData.DamageText) do
	begin
		if (IAData.DamageText[i].Exists) then
		begin
		Alpha:=IAData.DamageText[i].FadeTime / DAMAGE_FADE_TIME;
		x:=IAData.DamageText[i].x;
		y:=IAData.DamageText[i].y;
		DrawText(IAData.DamageText[i].Value,RGBAFloatColor(0,0,0,Alpha),x,y);
		end;
	end;
end;

procedure DrawExplosion(IAData:MainGameData);
var
	i:Integer;
	x,y:Single;
	Alpha:Byte;
begin
	for i:=0 to High(IAData.Explosion) do
	begin
		if (IAData.Explosion[i].Exists) then
		begin
		Alpha:=Round(255 * IAData.Explosion[i].FadeTime / EXPLOSION_FADE_TIME);
		x:=IAData.Explosion[i].x;
		y:=IAData.Explosion[i].y;
		FillCircle(RGBAColor(255,127,39,Alpha),x,y,IAData.Explosion[i].Radius);
		end;
	end;
end;

procedure DrawGirls(IAData:MainGameData);
var
	i:Integer;
	x,y:Integer;
begin
	for i:=0 to High(IAData.Girl) do
	begin
		if (IAData.Girl[i].Exists) then
		begin
		//DrawBitmap(IAData.Girl[i].Looks,IAData.Girl[i].x,IAData.Girl[i].y);
		end;
	end;
end;

procedure DrawGame(IAData:MainGameData);
begin
	ClearScreen(colorWhite);
	DrawMap(ColorGreen,IAData.GroundMap);
	DrawPlayers(IAData);
	DrawHealthBars(IAData);
	DrawProjectiles(IAData);
	DrawExplosion(IAData);
	DrawAngleMarkers(IAData);
	DrawDamageText(IAData);
	DrawHUD(IAData);
	//DrawGirls(IAData);
end;

procedure InitialiseCombat(var IAData:MainGameData);
var
	i,j,k:Integer;
	newMap: Map;
begin
	//MapType will generate terrain, hence, GenerateTerrain and similar functions need reworking
	//newMap:=RandomMapType()
	//ClearTerrain(IAData.GroundMap);
	GenerateTerrain(IAData.GroundMap,round(SCREEN_HEIGHT / 5),fRandBtw(0.7, 1.6), Linear);
	IAData.currentPlayer:=RandomPlayer(IAData);
	ShowPanel(IAData.ShellPanel);
	IAData.ShowingShellDesc:=false;
	for i:=0 to High(IAData.Player) do
	begin
		IAData.Player[i].Pos:=Rnd(SCREEN_WIDTH-10)+5;
		IAData.Player[i].Exists:=true;
		IAData.Player[i].GunAngle:=0;
		IAData.Player[i].Facing:=Direction(Rnd(2));
		IAData.Player[i].HP:=IAData.SPG[Ord(IAData.Player[i].SPG)].MaxHP;
		IAData.Player[i].PreviousProjectilePower:=0;
		IAData.Player[i].ActiveShellIndex:=0;
		IAData.Player[i].TraverseLeft:=IAData.SPG[Ord(IAData.Player[i].SPG)].TraverseLimit;
		
		IAData.Player[i].Sprite.HullBitmap:=IAData.SPG[Ord(IAData.Player[i].SPG)].Sprite.HullBitmap;
		IAData.Player[i].Sprite.BarrelBitmap:=IAData.SPG[Ord(IAData.Player[i].SPG)].Sprite.BarrelBitmap;
		IAData.Player[i].Sprite.GirlBitmap:=IAData.SPG[Ord(IAData.Player[i].SPG)].Sprite.GirlBitmap;
		
	end;
	
	for j:=0 to High(IAData.Projectile) do
	begin
		IAData.Projectile[j].Exists:=false;
		for k:=0 to High(IAData.Projectile[j].Tracer) do
		begin
			IAData.Projectile[j].Tracer[k].Exists:=false;
		end;
	end;
	
	for j:=0 to High(IAData.DamageText) do
	begin
		IAData.DamageText[j].Exists:=false;
		IAData.DamageText[j].FadeTime:=0;
	end;
	
	for j:=0 to High(IAData.Girl) do
	begin
		IAData.Girl[j].Exists:=false;
		IAData.Girl[j].FadeTime:=0;
	end;
	
	for j:=0 to High(IAData.Explosion) do
	begin
		IAData.Explosion[j].Exists:=false;
		IAData.Explosion[j].FadeTime:=0;
	end;
	
	SetShellTypes(IAData);
end;

function AngleOfSlope(IAData:MainGameData):Single; //Returns Angle in Rad
var
	newHeight, currentHeight, heightDiff, angle:Single;
	pos,distanceTo:Integer;
	i:Integer;
	facing:Direction;
begin
	i:=IAData.CurrentPlayer;
	pos:=Round(IAData.Player[i].pos);
	facing:=IAData.Player[i].Facing;
	currentHeight:=IAData.GroundMap[pos];
	newHeight:=currentHeight;
	if (facing = Right) then newHeight:=IAData.GroundMap[pos+VEHICLE_SLOPE_RADIUS];
	if (facing = Left) then newHeight:=IAData.GroundMap[pos-VEHICLE_SLOPE_RADIUS];
	heightDiff:=newHeight-currentHeight;
	
	if not (newHeight=currentHeight) then
	begin
		angle:=arctan(heightDiff / VEHICLE_SLOPE_RADIUS);
		result:=angle;
	end else begin
		result:=0;
	end;
end;

function SlopeMultiplier(IAData:MainGameData):Single;
begin
	result:=1-(AngleOfSlope(IAData) * VEHICLE_SLOPE_MULTIPLIER);
end;

procedure SimulateVehicleMovement(var IAData:MainGameData);
var
	acc,slope:Single;
	i:Integer;
begin
	i:=IAData.CurrentPlayer;
	acc:=IAData.Player[i].acc;
	slope:=SlopeMultiplier(IAData);
	IAData.Player[i].vel+=acc;
	IAData.Player[i].vel*=slope;
	IAData.Player[i].vel*=VEHICLE_FRICTION;
	if (IAData.Player[i].BrakesOn) then IAData.Player[i].vel*=VEHICLE_BRAKE;
	if (IAData.Player[i].vel > VEHICLE_MAXSPEED) then IAData.Player[i].vel:=VEHICLE_MAXSPEED; 
	if (IAData.Player[i].vel < -VEHICLE_MAXSPEED) then IAData.Player[i].vel:=-VEHICLE_MAXSPEED; 
	
	
	//WriteLn('Current Player: ',IAData.Player[i].Name,', Traverse left: ',IAData.Player[i].TraverseLeft);
	if (IAData.Player[i].TraverseLeft-IAData.Player[i].vel>=0) then
	begin
		IAData.Player[i].pos+=IAData.Player[i].vel;
		IAData.Player[i].TraverseLeft-=abs(IAData.Player[i].vel);
	end;
	
	if (IAData.Player[i].pos > SCREEN_WIDTH) then IAData.Player[i].pos:=SCREEN_WIDTH;
	if (IAData.Player[i].pos < 0) then IAData.Player[i].pos:=0;
end;

procedure UpdatePlayerFacing(var IAData:MainGameData);
var
	acc:Single;
	i:Integer;
begin
	i:=IAData.CurrentPlayer;
	acc:= IAData.Player[i].acc;
	if (acc > 0) then IAData.Player[i].Facing:=Right;
	if (acc < 0) then IAData.Player[i].Facing:=Left;
end;

procedure UpdateVehicleAngle(var IAData:MainGameData);
var
	i:Integer;
	slopeAngle:Single;
begin
	i:=IAData.CurrentPlayer;
	//WriteLn('[UpdateVehicleAngle]: Current Player is: ',i);
	slopeAngle:=AngleOfSlope(IAData);
	
	IAData.Player[i].VehicleAngle:=slopeAngle;
end;

procedure CyclePlayers(var IAData:MainGameData);
var
	i:Integer;
begin
	//WriteLn('[CyclePlayers]');	
	i:=IAData.CurrentPlayer;
	//WriteLn('[CyclePlayers]#1: Current Player is: ',i);	
	repeat
	i+=1;
	if (i>High(IAData.Player)) then i:=Low(IAData.Player);
	until IAData.Player[i].Exists;
	if (i>High(IAData.Player)) then i:=Low(IAData.Player);
	//WriteLn('[CyclePlayers]#2: Current Player is: ',i);	
	//WriteLn('[CyclePlayers]#3: Current Player is: ',i);	
	IAData.CurrentPlayer:=i;
	SetShellTypes(IAData);
	
	IAData.Player[i].TraverseLeft:=IAData.SPG[Ord(IAData.Player[i].SPG)].TraverseLimit;
	//WriteLn('[CyclePlayers]: End');	
	//SelectRadioButton(RadioGroupFromId('ShellType'),IAData.Player[i].ActiveShellIndex);
end;

procedure CreateGirl(var IAData:MainGameData);
var
	i,j,pos,middleOfMap,moveDirection,girlPosition:Integer;
	objectCreated:Boolean;
	placement:Direction;
begin
	i:=IAData.CurrentPlayer;
	pos:=Round(IAData.Player[i].pos);
	middleOfMap:=Round(SCREEN_WIDTH/2);
	if (pos > middleOfMap) then
	begin
		placement:=Right;
		moveDirection:=-1;
		girlPosition:=Round(SCREEN_WIDTH / 2 - GIRL_POSITION_OFFSET);
	end else begin
		placement:=Left;
		moveDirection:=1;
		girlPosition:=GIRL_POSITION_OFFSET;
	end;
	
	j:=-1;
	repeat
		j+=1;
		if not (IAData.Girl[j].Exists) then
		begin
			//WriteLn('Drawing a girl!');
			IAData.Girl[j].Exists:=true;
			IAData.Girl[j].Side:=placement;
			IAData.Girl[j].Looks:=IAData.SPG[Ord(IAData.Player[i].SPG)].Sprite.GirlBitmap;
			IAData.Girl[j].FadeTime:=GIRL_FADE_TIME;
			IAData.Girl[i].dx:=GIRL_MOVE_SPEED * moveDirection;
			IAData.Girl[i].x:=girlPosition;
			IAData.Girl[i].y:=GIRL_HEIGHT_OFFSET;
			objectCreated:=true;
		end;
		if (j=High(IAData.Girl)) then objectCreated:=true;
	until objectCreated;
	
end;

procedure FireProjectile(var IAData:MainGameData);
var
	i,j,k:Integer;
	emptySlotFound:Boolean;
	effectivePower,angle:Single;
begin
	i:=IAData.CurrentPlayer;
	emptySlotFound:=false;
	IAData.Player[i].PreviousProjectilePower:=IAData.Player[i].ProjectilePower;
	effectivePower:=IAData.Player[i].ProjectilePower * POWER_TO_PXL;
	angle:=IAData.Player[i].GunAngle+IAData.Player[i].VehicleAngle;
	//WriteLn('Firing projectile Now! with power: ',IAData.Player[i].ProjectilePower:0:2);
	
	j:=-1;
	repeat
	j+=1;
	if not (IAData.Projectile[j].Exists) then 
	begin
		emptySlotFound:=true;
		IAData.Projectile[j].Exists:=true;
		IAData.Projectile[j].Owner:=i;
		//IAData.Projectile[j].Shell:=ShellType(IAData.ActiveShellIndex);
		IAData.Projectile[j].Shell:=ShellType(IAData.Player[i].ActiveShellIndex);
		IAData.Projectile[j].Colour:=IAData.ShellColour[Ord(IAData.Projectile[j].Shell)];
		IAData.Projectile[j].x:=IAData.Player[i].pos;
		IAData.Projectile[j].y:=IAData.GroundMap[Round(IAData.Player[i].pos)];
		IAData.Projectile[j].dx:=effectivePower * cos(angle);
		IAData.Projectile[j].dy:=effectivePower * sin(angle);
		if (IAData.Player[i].Facing=Left) then IAData.Projectile[j].dx*=-1;
		
		for k:=0 to High(IAData.Projectile[j].Tracer) do
		begin
			IAData.Projectile[j].Tracer[k].Exists:=False;
			IAData.Projectile[j].Tracer[k].FadeTime:=0;
		end;
		//WriteLn('[FireProjectile]: Created Tracers, At end ');	
	end;
	if (j=High(IAData.Projectile)) then emptySlotFound:=true;
	until emptySlotFound;
	
	//CreateGirl(IAData);
	//if (j=-1) then //WriteLn('Maximum number of projectiles reached!');
	IAData.Player[i].ProjectilePower:=0;
	
	CyclePlayers(IAData);
end;

procedure CreateExplosion(var IAData:MainGameData;x,y:Single);
var
	j:Integer;
	objectCreated:Boolean;
begin
	j:=-1;
	repeat
		j+=1;
		if not (IAData.Explosion[j].Exists) then
		begin
			IAData.Explosion[j].Exists:=true;
			IAData.Explosion[j].x:=x;
			IAData.Explosion[j].y:=y;
			IAData.Explosion[j].Radius:=1;
			IAData.Explosion[j].FadeTime:=EXPLOSION_FADE_TIME;
			objectCreated:=true;
		end;
		if (j=High(IAData.Explosion)) then objectCreated:=true;
	until objectCreated;
end;

procedure DestroyGround(var IAData:MainGameData;pos:Single;Radius:Integer);
var
	i,x:Integer;
begin
	for i:=-Radius to Radius do
	begin
		x:=Round(pos)+i;
		if (x>0) and (x<High(IAData.GroundMap)) then
		begin
			IAData.GroundMap[x]-=(Sqrt(Sqr(Radius)-Sqr(i))) / 7;
			IAData.GroundMap[x]-=(Radius * cos( (i * 3.14) / (1.1 * Radius)) + 0.9 * Radius + rnd(3)) / 8;
		end;
	end;
	CreateExplosion(IAData,pos,GroundPosition(Round(pos),IAData));
end;

procedure CreateDamageText(var IAData:MainGameData; effectiveDamage:String;hitPlayer:Integer);
var
	j,k:Integer;
	objectCreated:Boolean;
begin
	objectCreated:=false;
	
	j:=-1;
	repeat
		j+=1;
		if not (IAData.DamageText[j].Exists) then
		begin
			IAData.DamageText[j].Exists:=true;
			IAData.DamageText[j].Value:=effectiveDamage;
			IAData.DamageText[j].x:=Round(IAData.Player[hitPlayer].pos);
			IAData.DamageText[j].y:=GroundPosition(Round(IAData.DamageText[j].x),IAData);
			IAData.DamageText[j].dy:=DAMAGE_TEXT_SPEED;
			IAData.DamageText[j].FadeTime:=DAMAGE_FADE_TIME;
			objectCreated:=true;
		end;
		if (j=High(IAData.DamageText)) then objectCreated:=true;
	until objectCreated;
end;

procedure DamagePlayers(var IAData:MainGameData; projectile:ProjectileData);
var
	i,j,xMin,xMax,radius,pos,distance:Integer;
	baseDamage,effectiveDamage:Integer;
	damageMultiplier:Single;
	damageString:String;
begin
	i:=projectile.Owner;
	pos:=Round(projectile.x);
	baseDamage:=IAData.SPG[Ord(IAData.Player[i].SPG)].ShellStat[Ord(projectile.Shell)].Damage;
	radius:=IAData.SPG[Ord(IAData.Player[i].SPG)].ShellStat[Ord(projectile.Shell)].BlastRadius;
	xMin:=pos - radius;
	xMax:=pos + radius;
	if (xMin<0) then xMin:=0;
	if (xMax>High(IAData.GroundMap)) then xMax:=High(IAData.GroundMap);
	
	
	for j:=0 to High(IAData.Player) do
	begin
		if (IAData.Player[j].Exists) then
		begin
			if (IAData.Player[j].pos > xMin) and  (IAData.Player[j].pos < xMax) then
			begin
				distance:=abs(Round(IAData.Player[j].pos - pos));
				damageMultiplier:=1-(Sqr(distance) / Sqr(radius));
				effectiveDamage:=Round(damageMultiplier * baseDamage);
				//WriteLn('Distance: ',distance,', Multiplier: ',damageMultiplier:0:2, 'Base Damage: ',baseDamage,' effectiveDamage: ',effectiveDamage, ' Player: ',j);
				//WriteLn('Position pos: ',projectile.x:0:2,' xMin: ',xMin,' xMax: ',xMax,' Playerpos: ',IAData.Player[j].pos:0:2);
				IAData.Player[j].HP-=effectiveDamage;
				str(effectiveDamage,damageString);
				if (damageMultiplier>0.97) then damageString:=Concat(damageString,'!!');
				CreateDamageText(IAData,damageString,j);
			end;
		end;
	end;
end;

procedure UpdateGun(var IAData:MainGameData);
var
	i:Integer;
begin
	i:=IAData.CurrentPlayer;
	//WriteLn('[UpdateGun]: Current Player is: ',i);	
	if (IAData.Player[i].Exists) then
		if (IAData.Player[i].FireProjectile) then FireProjectile(IAData);
end;

procedure SimulateProjectiles(var IAData:MainGameData);
var
	i,j,k,explRadius:Integer;
	velocityLoss:Single;
	Alpha:Byte;
	tracerCreated:Boolean;
begin
	i:=IAData.CurrentPlayer;
	
	for j:=0 to High(IAData.Projectile) do
	begin
		if (IAData.Projectile[j].Exists) then
		begin
			IAData.Projectile[j].x+=IAData.Projectile[j].dx;
			IAData.Projectile[j].y+=IAData.Projectile[j].dy;
			
			velocityLoss:=1-IAData.SPG[Ord(IAData.Player[i].SPG)].ShellStat[Ord(IAData.Projectile[j].Shell)].VelocityBleed;
			velocityLoss:=1-(velocityLoss*VELOCITY_LOSS_MULTIPLIER);
			//WriteLn('Velocity Bleed: ', velocityLoss:0:4);
			IAData.Projectile[j].dx*=velocityLoss;
			IAData.Projectile[j].dy-=GRAVITY_ACC;  
			
			if(IAData.Projectile[j].x>High(IAData.GroundMap)) then IAData.Projectile[j].Exists:=false;
			if(IAData.Projectile[j].x<0) then IAData.Projectile[j].Exists:=false;
			if(IAData.Projectile[j].y<0) then IAData.Projectile[j].Exists:=false;
			k:=0;
			tracerCreated:=false;
			repeat
				if not (IAData.Projectile[j].Tracer[k].Exists) then
				begin
					IAData.Projectile[j].Tracer[k].FadeTime:=TRACER_FADE_TIME;
					IAData.Projectile[j].Tracer[k].Exists:=true;
					IAData.Projectile[j].Tracer[k].Colour:=IAData.Projectile[j].Colour;
					IAData.Projectile[j].Tracer[k].x:=IAData.Projectile[j].x;
					IAData.Projectile[j].Tracer[k].y:=IAData.Projectile[j].y;
					tracerCreated:=true;
				end;
				if (k>=High(IAData.Projectile[j].Tracer)) then tracerCreated:=true;
				k+=1;
			until tracerCreated;
			
			if(IAData.Projectile[j].y<IAData.GroundMap[Round(IAData.Projectile[j].x)]) then
			begin
				explRadius:=IAData.SPG[Ord(IAData.Player[i].SPG)].ShellStat[Ord(IAData.Projectile[j].Shell)].BlastRadius;
				//WriteLn('Explosion Radius: ',explRadius);
				DestroyGround(IAData,IAData.Projectile[j].x,explRadius);
				DamagePlayers(IAData,IAData.Projectile[j]);
				IAData.Projectile[j].Exists:=false;
			end;
		end;
		
		for k:=0 to High(IAData.Projectile[j].Tracer) do
		begin
			if (IAData.Projectile[j].Tracer[k].Exists) then
			begin
				IAData.Projectile[j].Tracer[k].FadeTime-=1;
				if (IAData.Projectile[j].Tracer[k].FadeTime<=0) then
				begin
					IAData.Projectile[j].Tracer[k].FadeTime:=0;
					IAData.Projectile[j].Tracer[k].Exists:=false;
				end else begin //Fade Time >0
					Alpha:= Round(255 * (IAData.Projectile[j].Tracer[k].FadeTime / TRACER_FADE_TIME));
					IAData.Projectile[j].Tracer[k].Colour:=RGBAColor(RedOf(IAData.Projectile[j].Colour),BlueOf(IAData.Projectile[j].Colour),GreenOf(IAData.Projectile[j].Colour),Alpha);
					//WriteLn('Alpha of Tracer ',k,': ',Alpha:0:2);
				end;
			end;
		end;
		
	end;
end;

procedure SimulateGirl(var IAData:MainGameData);
var
	i:Integer;
	alpha:Single;
begin
	for i:=0 to High(IAData.Girl) do
	begin
		if (IAData.Girl[i].Exists) then
		begin
			Alpha:=(IAData.Girl[i].FadeTime / GIRL_FADE_TIME);
			IAData.Girl[i].FadeTime-=1;
			IAData.Girl[i].x+=IAData.Girl[i].dx;
			SetOpacity(IAData.Girl[i].Looks,Alpha);
			//WriteLn('Alpha: ',alpha:0:2);
		end;
		
		if (IAData.Girl[i].FadeTime<=0) then
			IAData.Girl[i].Exists:=false;
	end;
end;

procedure SimulateDamageText(var IAData:MainGameData);
var
	i:Integer;
begin
	for i:=0 to High(IAData.DamageText) do
	begin
		if (IAData.DamageText[i].Exists) then
		begin
			IAData.DamageText[i].y-=IAData.DamageText[i].dy;
			IAData.DamageText[i].FadeTime-=1;
		end;
		
		if (IAData.DamageText[i].FadeTime<=0) then
		begin
			IAData.DamageText[i].Exists:=false;
		end;
		
	end;
end;

procedure SimulateExplosion(var IAData:MainGameData);
var
	i:Integer;
begin
	for i:=0 to High(IAData.Explosion) do
	begin
		if (IAData.Explosion[i].Exists) then
		begin
			IAData.Explosion[i].radius+=1;
			IAData.Explosion[i].FadeTime-=1;
		end;
		
		if (IAData.Explosion[i].FadeTime<=0) then
		begin
			IAData.Explosion[i].Exists:=false;
		end;
		
	end;
end;

procedure UpdateExistences(var IAData:MainGameData);
var
	i:Integer;
begin
	//WriteLn('At Existences');
	i:=IAData.CurrentPlayer;
	if not (IAData.Player[i].Exists) then
		CyclePlayers(IAData);
		
	//WriteLn('Before For');
	for i:=0 to High(IAData.Player) do
	begin
		//WriteLn('Inside For');
		if (IAData.Player[i].Exists) then
		begin
			//WriteLn('Player ',i, 'existence');
			if (IAData.Player[i].HP <= 0) then
			begin
				IAData.Player[i].Exists:=false;
				CreateExplosion(IAData,IAData.Player[i].pos,GroundPosition(Round(IAData.Player[i].pos),IAData));
				CyclePlayers(IAData);
				//drawExplosion
			end;
		end;
	end;
end;

procedure SimulateObjects(var IAData:MainGameData);
begin
	SimulateProjectiles(IAData);
	SimulateDamageText(IAData);
	SimulateGirl(IAData);
	SimulateExplosion(IAData);
end;

procedure CheckForVictory(var IAData:MainGameData; var battleEnded:Boolean);
var
	i,players:Integer;
begin
	players:=0;
	for i:=0 to High(IAData.Player) do
	begin
		if IAData.Player[i].Exists then players+=1;
	end;
	if (players<=1) then battleEnded:=true;
end;

procedure UpdateGame(var IAData:MainGameData;var battleEnded:Boolean);
var
	j:Integer;
begin
	UpdateInterface();
	UpdatePlayerFacing(IAData);
	//WriteLn('[UpdatedPlayerFacing]');
	SimulateVehicleMovement(IAData);
	//WriteLn('[SimulateVehicleMovement]');
	UpdateVehicleAngle(IAData);
	//WriteLn('[UpdateVehicleAngle]');
	UpdateGun(IAData);
	//WriteLn('[UpdateGame]');
	SimulateObjects(IAData);
	//WriteLn('[SimulateObjects]');
	UpdateExistences(IAData);
	//WriteLn('[UpdateExistences]');
	CheckForVictory(IAData,battleEnded);
end;

procedure ToggleInfoButton(var ShowingShellDesc:Boolean);
begin
	case ShowingShellDesc of
		true: ShowingShellDesc:=false;
		false: ShowingShellDesc:=true;
	end;
end;

procedure UpdateSelectedShell(var IAData:MainGameData);
var
	i:Integer;
begin
	i:=IAData.CurrentPlayer;
	
	case RegionClickedID() of
		'ShellButton1' : IAData.Player[i].ActiveShellIndex:=0;
		'ShellButton2' : IAData.Player[i].ActiveShellIndex:=1;
		'ShellButton3' : IAData.Player[i].ActiveShellIndex:=2;
		'ShellButton4' : IAData.Player[i].ActiveShellIndex:=3;
		'InfoButton' : ToggleInfoButton(IAData.ShowingShellDesc);
		//'ShellButton5' : IAData.Player[i].ActiveShellIndex:=4;
		//'ShellButton6' : IAData.Player[i].ActiveShellIndex:=5;
		//'ShellButton7' : IAData.Player[i].ActiveShellIndex:=6;
		
	end;
	SetShellTypes(IAData);
	//WriteLn('ActiveShellIndex of player ',i,' :',IAData.Player[i].ActiveShellIndex);
end;

procedure HandleInput(var IAData:MainGameData);
var
	radIncrement,radElevation,radDepression,maxPower:Single;
	i:Integer;
begin
	ProcessEvents();
	UpdateInterface();
	UpdateSelectedShell(IAData);
	i:=IAData.CurrentPlayer;
	IAData.Player[i].acc:=0;
	IAData.Player[i].BrakesOn:=true;
	IAData.Player[i].FireProjectile:=false;
	radIncrement:=DEGREE_INCREMENT * 2 * pi / 360;
	radElevation:=Rad(IAData.SPG[Ord(IAData.Player[i].SPG)].GunElevation);
	radDepression:=-Rad(IAData.SPG[Ord(IAData.Player[i].SPG)].GunDepression);
	maxPower:=IAData.SPG[Ord(IAData.Player[i].SPG)].MaxGunVelocity;
	
	if (KeyDown(VK_LEFT)) then IAData.Player[i].acc := -VEHICLE_ACC;
	if (KeyDown(VK_RIGHT)) then IAData.Player[i].acc := VEHICLE_ACC;
	if (IAData.Player[i].acc<>0) then IAData.Player[i].BrakesOn := false;
	if (KeyDown(VK_RSHIFT)) then IAData.Player[i].BrakesOn := false;
	if (KeyDown(VK_LSHIFT)) then IAData.Player[i].BrakesOn := false;
	if (KeyDown(VK_SPACE)) then IAData.Player[i].ProjectilePower += POWER_INCREMENT;
	if (KeyReleased(VK_SPACE)) then IAData.Player[i].FireProjectile := true;
	   
	if (KeyDown(VK_UP)) then IAData.Player[i].GunAngle += radIncrement;
	if (KeyDown(VK_DOWN)) then IAData.Player[i].GunAngle -= radIncrement;
	
	if (IAData.Player[i].pos<0) then IAData.Player[i].pos:=0;
	if (IAData.Player[i].pos>High(IAData.GroundMap)) then IAData.Player[i].pos:=High(IAData.GroundMap);
	if (IAData.Player[i].ProjectilePower > maxPower) then IAData.Player[i].ProjectilePower:=maxPower;
	if (IAData.Player[i].GunAngle > radElevation) then IAData.Player[i].GunAngle:=radElevation;
	if (IAData.Player[i].GunAngle < radDepression) then IAData.Player[i].GunAngle:=radDepression;
	
end;

procedure Battle(var IAData:MainGameData);
var
	battleEnded:Boolean;
begin
	battleEnded:=false;
	repeat
		HandleInput(IAData);
		//WriteLn('Handled Input');
		UpdateGame(IAData,battleEnded);
		//WriteLn('Updated Game');
		DrawGame(IAData);
		//WriteLn('Drawn Game');
		RefreshScreen(TARGET_FPS);
		
		if (WindowCloseRequested()) then battleEnded:=true;
	until battleEnded;
end;

procedure SetupPanels(var IAData:MainGameData);
begin
	IAData.ShellPanel:=LoadPanel('shellGroup.txt');
	IAData.ShellDesc:=LoadPanel('shellsdesc.txt');
end;

procedure UpdatePostGame(var IAData:MainGameData);
var
	j:Integer;
begin
	UpdateInterface();
	UpdatePlayerFacing(IAData);
	//WriteLn('[UpdatedPlayerFacing]');
	SimulateVehicleMovement(IAData);
	//WriteLn('[SimulateVehicleMovement]');
	UpdateVehicleAngle(IAData);
	//WriteLn('[UpdateVehicleAngle]');
	UpdateGun(IAData);
	//WriteLn('[UpdateGame]');
	SimulateObjects(IAData);
	//WriteLn('[SimulateObjects]');
end;

procedure ShowVictoryScreen(var IAData:MainGameData);
var
	i,victor,players:Integer;
	victoryStr:String;
begin
	players:=0;
	UpdateExistences(IAData);
	for i:=0 to High(IAData.Player) do
	begin
		if IAData.Player[i].Exists then
		begin
			players:=1;
			victor:=i;
		end;
	end;
	case players of
		1: victoryStr:=Concat(IAData.Player[victor].Name, ' has won!');
		0: victoryStr:='No one has won! It''s a draw!';
	end;
	repeat
		ProcessEvents();
		ClearScreen(ColorWhite);
		DrawGame(IAData);
		HandleInput(IAData);
		UpdatePostGame(IAData);
		DrawTextCentre(ColorBlack,victoryStr,SCREEN_WIDTH/2,250);
		DrawTextCentre(ColorGrey,'Click to continue',SCREEN_WIDTH/2,270);
		RefreshScreen(TARGET_FPS);
	until MouseClicked(LeftButton);
end;

procedure Main();
var
	IAData:MainGameData;
begin
	OpenAudio();
	InitialiseData(IAData,PathToResource(ARTY_DATA_FILE));
	SetupPanels(IAData);
	LoadResources(IAData);
	OpenGraphicsWindow('Artillery',SCREEN_WIDTH,SCREEN_HEIGHT);
	
	repeat
		Menu(IAData);
		if not IAData.ExitRequested then
		begin
			InitialiseCombat(IAData);
			Battle(IAData);
			ShowVictoryScreen(IAData);
			if WindowCloseRequested() then IAData.ExitRequested:=True;
		end;
	until IAData.ExitRequested=True;
	ReleaseAllResources();
end;

begin
	Main();
end.